{"remainingRequest":"C:\\Users\\Patricia\\Desktop\\Raciel2\\mecvision-master\\mecvision-master\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\Patricia\\Desktop\\Raciel2\\mecvision-master\\mecvision-master\\node_modules\\cache-loader\\dist\\cjs.js??ref--0-0!C:\\Users\\Patricia\\Desktop\\Raciel2\\mecvision-master\\mecvision-master\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!C:\\Users\\Patricia\\Desktop\\Raciel2\\mecvision-master\\mecvision-master\\src\\components\\Analysis.vue?vue&type=script&lang=js&","dependencies":[{"path":"C:\\Users\\Patricia\\Desktop\\Raciel2\\mecvision-master\\mecvision-master\\src\\components\\Analysis.vue","mtime":1704597293260},{"path":"C:\\Users\\Patricia\\Desktop\\Raciel2\\mecvision-master\\mecvision-master\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1704599107236},{"path":"C:\\Users\\Patricia\\Desktop\\Raciel2\\mecvision-master\\mecvision-master\\node_modules\\babel-loader\\lib\\index.js","mtime":1704599126277},{"path":"C:\\Users\\Patricia\\Desktop\\Raciel2\\mecvision-master\\mecvision-master\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1704599107236},{"path":"C:\\Users\\Patricia\\Desktop\\Raciel2\\mecvision-master\\mecvision-master\\node_modules\\vue-loader\\lib\\index.js","mtime":1704599156770}],"contextDependencies":[],"result":["import _toConsumableArray from \"C:\\\\Users\\\\Patricia\\\\Desktop\\\\Raciel2\\\\mecvision-master\\\\mecvision-master\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/toConsumableArray\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es7.object.values\";\nimport \"regenerator-runtime/runtime\";\nimport _asyncToGenerator from \"C:\\\\Users\\\\Patricia\\\\Desktop\\\\Raciel2\\\\mecvision-master\\\\mecvision-master\\\\node_modules\\\\@babel\\\\runtime-corejs2/helpers/esm/asyncToGenerator\";\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\nimport { eventBus } from \"../main.js\";\nexport default {\n  data: function data() {\n    return {\n      drawer: false,\n      infoExpanded: false,\n      eggsize: null,\n      analyzedImage: null,\n      imageSize: '',\n      imageDepth: '',\n      imageChannels: '',\n      imageType: '',\n      showAnalysis: true,\n      showBottom: false,\n      firstRun: true,\n      active: null,\n      analyzedImages: [{\n        output: 'src',\n        source: 'src2'\n      }, {\n        output: 'threshold',\n        source: 'src3'\n      }, {\n        output: 'objects',\n        source: 'src5'\n      }, {\n        output: 'outlines',\n        source: 'src6'\n      }, {\n        output: 'overlay',\n        source: 'src7'\n      }],\n      analyzedImagesPretty: [this.$i18n.t('Source Image'), this.$i18n.t('Threshold'), this.$i18n.t('Detected Objects'), this.$i18n.t('Sorted Markers'), this.$i18n.t('Outlined Overlay')],\n      analysisStarted: false,\n      analysisComplete: false,\n      threshValue: 120,\n      minEggRadius: 5,\n      maxEggRadius: 13,\n      maxEggCluster: 30,\n      singlesCount: 0,\n      clustersCount: 0,\n      singlesArray: [],\n      singlesTotalArea: 0,\n      clustersTotalArea: 0,\n      avgClusterArea: 0,\n      avgEggsPerCluster: 0,\n      singlesAvg: 0,\n      clustersArray: [],\n      singlesCalculated: 0,\n      eggBoxes: 0,\n      detectedObjectsArray: [],\n      detectedObjectsArrayList: [],\n      totalEggs: 0,\n      window: 0,\n      length: 5,\n      detailsDialog: false\n    };\n  },\n  created: function created() {\n    var _this = this;\n\n    eventBus.$on('imageType', function (imageType) {\n      if (imageType === 0) {\n        _this.threshValue = 116;\n        _this.minEggRadius = 1;\n        _this.maxEggRadius = 8;\n        _this.maxEggCluster = 8;\n      } else if (imageType === 1) {\n        _this.threshValue = 120;\n        _this.minEggRadius = 5;\n        _this.maxEggRadius = 13;\n        _this.maxEggCluster = 30;\n      } else {\n        _this.threshValue = 120;\n        _this.minEggRadius = 4;\n        _this.maxEggRadius = 14;\n        _this.maxEggCluster = 20;\n      }\n    });\n    eventBus.$on('rawImageReady', function (data) {\n      _this.analyzedImage = data;\n\n      _this.load();\n    });\n  },\n  methods: {\n    load: function () {\n      var _load = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee() {\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                eventBus.$emit('loadingDialog');\n                _context.next = 3;\n                return new Promise(function (resolve, reject) {\n                  return setTimeout(resolve, 2000);\n                });\n\n              case 3:\n                this.analyze();\n                this.turnImages();\n\n              case 5:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function load() {\n        return _load.apply(this, arguments);\n      }\n\n      return load;\n    }(),\n    rerender: function rerender() {\n      eventBus.$emit('forceRerender');\n    },\n    imageMenu: function imageMenu(index) {\n      this.active = index;\n    },\n    next: function next() {\n      this.window = this.window + 1 === this.length ? 0 : this.window + 1;\n    },\n    previous: function previous() {\n      this.window = this.window - 1 < 0 ? this.length - 1 : this.window - 1;\n    },\n    analyze: function () {\n      var _analyze = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee2() {\n        var src, overlay, gray, threshold, dilate, boundingBoxes, objects, outlines, M, anchor, contours, hierarchy, contoursObject, contoursValues, detectedObjectsArray, contoursColor, green, blue, red, grayColor, minEggArea, maxEggArea, maxClusterArea, i, contourMax, cnt, rect, point1, point2, _i, _i2, legend;\n\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                // Show 'analysis' components in Vue\n                this.analysisStarted = true; // INITIALIZATION\n                // Load image into OpenCV\n\n                src = cv.imread('analyzedImage');\n                overlay = src.clone(); // Show source image via OpenCV\n\n                cv.imshow('src', src); // Image Info for debugging\n\n                this.imageSize = src.size().width + ' x ' + src.size().height;\n                this.imageDepth = src.depth();\n                this.imageChannels = src.channels();\n                this.imageType = src.type(); // Create matrices for various analysis activites\n\n                gray = new cv.Mat();\n                threshold = new cv.Mat();\n                dilate = new cv.Mat();\n                boundingBoxes = new cv.Mat();\n                objects = cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC3);\n                outlines = new cv.Mat(src.rows, src.cols, cv.CV_8UC3, new cv.Scalar(255, 255, 255, 0)); // TRANSFORMATIONS\n                // Source to Grayscale\n\n                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY); // Grayscale to Threshold (binary, not adaptive)\n\n                cv.threshold(gray, threshold, this.threshValue, 255, cv.THRESH_BINARY); // Threshold to Dilate [and erode](create new matrix that can be written upon and anchor point (center))\n\n                M = cv.Mat.ones(3, 3, cv.CV_8U);\n                anchor = new cv.Point(-1, -1);\n                cv.dilate(threshold, dilate, M, anchor, 0, cv.BORDER_CONSTANT, cv.morphologyDefaultBorderValue()); // DRAW CONTOURS\n                // Create matrices to hold contour counts\n\n                contours = new cv.MatVector();\n                hierarchy = new cv.Mat();\n                contoursObject = [];\n                contoursValues = []; // Find contours\n\n                cv.findContours(dilate, contours, hierarchy, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE); // CALCULATE SINGLE EGGS AND CLUSTERS\n                // Initialize and/or reset single and cluster arrays, counts, and area placeholders for computation\n\n                detectedObjectsArray = [];\n                this.singlesArray = [];\n                this.clustersArray = [];\n                this.singlesCount = 0;\n                this.clustersCount = 0;\n                this.singlesTotalArea = 0;\n                this.clustersTotalArea = 0; // Define colors for contour object detection (boxes) and contour overlay (green=small, blue=single-egg, red=cluster)\n\n                contoursColor = new cv.Scalar(255, 255, 255);\n                green = new cv.Scalar(0, 225, 0, 255);\n                blue = new cv.Scalar(0, 0, 225, 255);\n                red = new cv.Scalar(255, 0, 0, 255);\n                grayColor = new cv.Scalar(100, 100, 100, 255);\n                minEggArea = Math.PI * (this.minEggRadius * this.minEggRadius);\n                maxEggArea = Math.PI * (this.maxEggRadius * this.maxEggRadius);\n                maxClusterArea = Math.PI * (this.maxEggCluster * this.maxEggCluster); // Main loop\n\n                for (i = 1; i < contours.size(); ++i) {\n                  contoursObject.push(cv.contourArea(contours.get(i)));\n                  contoursValues = Object.values(contoursObject);\n                  contourMax = Math.max.apply(Math, _toConsumableArray(contoursValues));\n\n                  if (contourMax === cv.contourArea(contours.get(i))) {} else {\n                    // Draw contours and bounding boxes for all objects detected from 'contours' matrix\n                    cnt = contours.get(i);\n                    rect = cv.boundingRect(cnt);\n                    cv.drawContours(objects, contours, i, contoursColor, 1, 8, hierarchy, 100);\n                    point1 = new cv.Point(rect.x - 5, rect.y - 5);\n                    point2 = new cv.Point(rect.x + rect.width + 5, rect.y + rect.height + 5);\n\n                    if (hierarchy.intPtr(0, i)[0] === -1 || hierarchy.intPtr(0, i)[1] === -1 || hierarchy.intPtr(0, i)[2] === -1 || hierarchy.intPtr(0, i)[3] === -1) {\n                      cv.rectangle(objects, point1, point2, green, 1, cv.LINE_AA, 0);\n                    } else {\n                      cv.rectangle(objects, point1, point2, green, 3, cv.LINE_AA, 0);\n                    } // Create matrix for points of objects for all objects, even if not calculated immediately (until individual boxes invoked)\n\n\n                    boundingBoxes = src.roi(rect);\n                    detectedObjectsArray.push(boundingBoxes); // Loop through all contours and sort/color by size, drawing on both outlines and overlay images (as well as counting towards array counts)\n\n                    if (cv.contourArea(contours.get(i)) <= minEggArea) {\n                      cv.drawContours(outlines, contours, i, grayColor, -1, cv.LINE_8, hierarchy, 0);\n                      cv.drawContours(overlay, contours, i, grayColor, 1, cv.LINE_8, hierarchy, 0);\n                    } else if (cv.contourArea(contours.get(i)) > minEggArea && cv.contourArea(contours.get(i)) <= maxEggArea) {\n                      cv.drawContours(outlines, contours, i, blue, -1, cv.LINE_8, hierarchy, 0);\n                      cv.drawContours(overlay, contours, i, blue, 1, cv.LINE_8, hierarchy, 0);\n                      this.singlesArray.push(cv.contourArea(contours.get(i)));\n                      ++this.singlesCount;\n                    } else if (cv.contourArea(contours.get(i)) > maxEggArea && cv.contourArea(contours.get(i)) <= maxClusterArea) {\n                      cv.drawContours(outlines, contours, i, red, -1, cv.LINE_8, hierarchy, 0);\n                      cv.drawContours(overlay, contours, i, red, 1, cv.LINE_8, hierarchy, 0);\n                      this.clustersArray.push(cv.contourArea(contours.get(i)));\n                      ++this.clustersCount;\n                    } else if (cv.contourArea(contours.get(i)) > maxClusterArea) {\n                      cv.drawContours(outlines, contours, i, grayColor, -1, cv.LINE_8, hierarchy, 0);\n                      cv.drawContours(overlay, contours, i, grayColor, 1, cv.LINE_8, hierarchy, 0);\n                    }\n                  }\n                } // CALCULATIONS\n                // Use array counts to calculate single size averages, single size area, cluster average, and cluster area\n\n\n                for (_i = 0; _i < this.singlesArray.length; _i++) {\n                  this.singlesTotalArea += this.singlesArray[_i];\n                }\n\n                this.singlesAvg = (this.singlesTotalArea / this.singlesArray.length).toFixed(2);\n                if (isNaN(this.singlesAvg)) this.singlesAvg = 0; // Calculate cluster area if not zero, append to total cluster area of image\n\n                if (this.clustersCount === 0) {} else {\n                  for (_i2 = 0; _i2 < this.clustersArray.length; _i2++) {\n                    this.clustersTotalArea += this.clustersArray[_i2];\n                  }\n                } // Calculate and convert to output formats\n\n\n                this.singlesCalculated = (this.clustersTotalArea / this.singlesAvg).toFixed(0);\n                if (isNaN(this.singlesCalculated)) this.singlesCalculated = 0;\n                this.avgClusterArea = (this.clustersTotalArea / this.clustersCount).toFixed(2);\n                if (isNaN(this.avgClusterArea)) this.avgClusterArea = 0;\n                this.avgEggsPerCluster = (this.avgClusterArea / this.singlesAvg).toFixed(1);\n                if (isNaN(this.avgEggsPerCluster)) this.avgEggsPerCluster = 0;\n                this.totalEggs = +this.singlesCount + +this.singlesCalculated;\n                this.eggEstimate = contours.size(); // Egg estimation from contours\n                // Show images\n\n                cv.imshow('src', src);\n                cv.imshow('src2', src);\n                cv.imshow('src3', src);\n                cv.imshow('src5', src);\n                cv.imshow('src6', src);\n                cv.imshow('src7', src);\n                cv.imshow('threshold', threshold);\n                cv.imshow('objects', objects);\n                cv.imshow('outlines', outlines);\n                cv.imshow('overlay', overlay); // Show legend image\n\n                legend = cv.imread('legendImage');\n                cv.circle(legend, new cv.Point(50, 50), this.minEggRadius, blue, 1); // Blue inner circle\n\n                cv.circle(legend, new cv.Point(50, 50), this.maxEggRadius, red, 1); // Red outer circle\n\n                cv.circle(legend, new cv.Point(50, 50), this.maxEggCluster, grayColor, 1); // Gray outer circle\n\n                cv.imshow('legendCanvas', legend);\n                legend.delete(); // Delete matrices to save on memory\n\n                src.delete();\n                gray.delete();\n                threshold.delete();\n                dilate.delete();\n                objects.delete();\n                outlines.delete();\n                overlay.delete();\n                M.delete();\n                contours.delete();\n                hierarchy.delete();\n\n              case 78:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function analyze() {\n        return _analyze.apply(this, arguments);\n      }\n\n      return analyze;\n    }(),\n    turnImages: function () {\n      var _turnImages = _asyncToGenerator(\n      /*#__PURE__*/\n      regeneratorRuntime.mark(function _callee3() {\n        var i;\n        return regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                i = 4;\n\n              case 1:\n                if (!(this.window < i)) {\n                  _context3.next = 7;\n                  break;\n                }\n\n                _context3.next = 4;\n                return new Promise(function (resolve, reject) {\n                  return setTimeout(resolve, 500);\n                });\n\n              case 4:\n                ++this.window;\n                _context3.next = 1;\n                break;\n\n              case 7:\n                _context3.next = 9;\n                return new Promise(function (resolve, reject) {\n                  return setTimeout(resolve, 500);\n                });\n\n              case 9:\n                this.analysisComplete = true; // After timeout, show bottom menu\n\n                _context3.next = 12;\n                return new Promise(function (resolve, reject) {\n                  return setTimeout(resolve, 500);\n                });\n\n              case 12:\n                this.showBottom = true;\n\n              case 13:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function turnImages() {\n        return _turnImages.apply(this, arguments);\n      }\n\n      return turnImages;\n    }()\n  }\n};",{"version":3,"sources":["Analysis.vue"],"names":[],"mappings":"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","sourcesContent":["<template>\n<div>\n\n  <v-container fluid>\n    <v-layout row wrap>\n      <v-flex xs12 md8 lg8 xl9 v-show=\"analysisStarted\">\n\n<!-- Analysis window -- increments between analyses, using Vuetify window components -->\n<v-window v-model=\"window\" class=\"elevation-5\">\n  <v-window-item v-for=\"item in analyzedImages\" :key=\"item.output\" :transition=\"false\" :reverse-transition=\"false\">\n\n    <!-- OpenCV injects to canvas items -->\n    <canvas :id=\"item.output\" class=\"imageCanvasOuter\" v-show=\"showAnalysis\">\n      <img class=\"imageCanvasInner\" id=\"analyzedImage\" :src=\"analyzedImage\" style=\"height:100px;\"/>\n    </canvas>\n\n    <!-- Keep a copy of the original source hidden under the analysis, for comparison toggle to work -->\n    <canvas :id=\"item.source\" class=\"imageCanvasOuter\" v-show=\"!showAnalysis\">\n      <img class=\"imageCanvasInner\" id=\"analyzedImage\" :src=\"analyzedImage\" />\n    </canvas>\n\n  </v-window-item>\n  </v-window>\n\n  <!-- Options for the analysis windows -->\n  <v-card class=\"my-3\">\n    <v-card-title>\n      <v-layout align-center wrap>\n        <v-flex>\n          <h1 :class=\"{'title': $vuetify.breakpoint.smAndDown, 'display-1': $vuetify.breakpoint.mdAndUp}\">{{ analyzedImagesPretty[this.window] }}</h1>\n          <h2 :class=\"{'subheading': $vuetify.breakpoint.smAndDown, 'title mt-2': $vuetify.breakpoint.mdAndUp}\">({{this.window+1}} {{ $t('of') }} {{this.length}})</h2>\n        </v-flex>\n        <v-spacer></v-spacer>\n        <v-layout justify-end row :class=\"{'': $vuetify.breakpoint.smAndDown, 'shrink': $vuetify.breakpoint.mdAndUp}\">\n        <v-flex shrink class=\"text-xs-center\">\n          <v-btn icon color=\"primary\" @click=\"previous\"><v-icon>chevron_left</v-icon>\n          </v-btn>\n        </v-flex>\n        <v-flex shrink class=\"text-xs-center\">\n          <v-btn icon color=\"primary\" @click=\"next\"><v-icon>chevron_right</v-icon>\n          </v-btn>\n        </v-flex>\n        </v-layout>\n      </v-layout>\n    </v-card-title>\n  </v-card>\n\n  </v-flex>\n\n  <v-flex xs12 md4 lg3 xl3 :class=\"{'pl-0': $vuetify.breakpoint.smAndDown, 'pl-3': $vuetify.breakpoint.mdAndUp}\" v-show=\"analysisComplete\">\n\n  <!-- Filters for fine-tuning image and analysis -->\n  <div v-show=\"drawer\">\n    <v-card class=\"mb-2\">\n      <v-card-title>\n        <h4 class=\"title\">{{ $t('Filters') }}</h4>\n      </v-card-title>\n      <v-card-text class=\"pt-0\">\n\n      <v-layout>\n        <v-tooltip bottom>\n        <template v-slot:activator=\"{ on }\">\n        <v-flex class=\"subheading\"><span v-on=\"on\">{{ $t('Image Threshold Adjustment') }}</span></v-flex>\n        </template>\n        <span>{{ $t('Image Threshold Adjustment Details') }}</span>\n        </v-tooltip>\n      </v-layout>\n\n      <v-layout row>\n        <v-flex>\n          <v-slider v-model=\"threshValue\" :max=\"255\" @change=\"analyze()\"></v-slider>\n        </v-flex>\n        <v-flex xs3 md2 xl2 mx-2>\n        <v-text-field solo v-model=\"threshValue\" hide-details single-line class=\"filter\"></v-text-field>\n        </v-flex>\n      </v-layout>\n\n      <v-layout>\n        <v-tooltip bottom>\n        <template v-slot:activator=\"{ on }\">\n        <v-flex class=\"subheading\"><span v-on=\"on\">{{ $t('Minimum Egg Size') }}</span></v-flex>\n        </template>\n        <span>{{ $t(\"Minimum Egg Size Details\") }}</span>\n        </v-tooltip>\n      </v-layout>\n\n      <v-layout row>\n        <v-flex mx-3>\n          <v-slider v-model=\"minEggRadius\" :min=\"0\" :max=\"100\" @change=\"analyze()\"></v-slider>\n        </v-flex>\n        <v-flex xs8 md5 lg4 xl3>\n        <v-text-field solo v-model=\"minEggRadius\" hide-details single-line></v-text-field>\n        </v-flex>\n      </v-layout>\n\n      <v-layout>\n        <v-tooltip bottom>\n        <template v-slot:activator=\"{ on }\">\n        <v-flex class=\"subheading\"><span v-on=\"on\">{{ $t('Maximum Egg Size') }}</span></v-flex>\n        </template>\n        <span>{{ $t('Maximum Egg Size Details') }}</span>\n        </v-tooltip>\n      </v-layout>\n\n      <v-layout row>\n        <v-flex mx-3>\n          <v-slider v-model=\"maxEggRadius\" :min=\"0\" :max=\"100\" @change=\"analyze()\"></v-slider>\n        </v-flex>\n        <v-flex xs8 md5 lg4 xl3>\n        <v-text-field solo v-model=\"maxEggRadius\" hide-details single-line></v-text-field>\n        </v-flex>\n      </v-layout>\n\n      <v-layout>\n        <v-tooltip bottom>\n        <template v-slot:activator=\"{ on }\">\n        <v-flex class=\"subheading\"><span v-on=\"on\">{{ $t('Maximum Cluster Size') }}</span></v-flex>\n        </template>\n        <span>{{ $t('Maximum Cluster Size Details') }}</span>\n        </v-tooltip>\n      </v-layout>\n\n      <v-layout row>\n        <v-flex mx-3>\n          <v-slider v-model=\"maxEggCluster\" :min=\"0\" :max=\"100\" @change=\"analyze()\"></v-slider>\n        </v-flex>\n        <v-flex xs8 md5 lg4 xl3>\n        <v-text-field solo v-model=\"maxEggCluster\" hide-details single-line></v-text-field>\n        </v-flex>\n      </v-layout>\n\n      <v-layout row wrap align-center>\n        <v-tooltip bottom>\n        <template v-slot:activator=\"{ on }\">\n        <v-flex class=\"subheading mb-1\">\n          <span v-on=\"on\">\n          <p class=\"mb-1\">{{ $t('Egg Size Scale') }}</p>\n          <p class=\"caption my-0\"><v-icon small color=\"rgba(0, 0, 225, 255)\">fiber_manual_record</v-icon> {{ $t('Minimum Egg Size') }}</p>\n          <p class=\"caption my-0\"><v-icon small color=\"rgba(225, 0, 0, 255)\">fiber_manual_record</v-icon> {{ $t('Maximum Egg Size') }}</p>\n          <p class=\"caption my-0\"><v-icon small color=\"rgba(100, 100, 100, 255)\">fiber_manual_record</v-icon> {{ $t('Too Large / Too Small') }}</p>\n          </span>\n          </v-flex>\n        </template>\n        <span>{{ $t('Egg Size Scale Details') }}</span>\n        </v-tooltip>\n\n        <v-flex>\n          <canvas id=\"legendCanvas\" style=\"margin: auto; display: block;\"><img id=\"legendImage\" src=\"/mecvision/img/legend.png\" /></canvas>\n        </v-flex>\n      </v-layout>\n\n    </v-card-text>\n  </v-card>\n\n  </div>\n\n  <!-- Analysis Card -- showing details -->\n  <v-card>\n    <v-card-title class=\"justify-end\">\n      <h4 class=\"title\">{{ $t('Analysis') }}</h4>\n      <v-spacer></v-spacer>\n      <v-btn class=\"mr-0\" color=\"primary\" dark @click=\"detailsDialog = true\">{{ $t('Details') }}</v-btn>\n    </v-card-title>\n\n    <v-divider></v-divider>\n\n    <v-list>\n      <v-list-tile>\n        <v-list-tile-content class=\"body-2\"><span><v-icon small color=\"rgba(0, 0, 225, 255)\">fiber_manual_record</v-icon>{{ $t('Single Eggs') }}</span></v-list-tile-content>\n        <v-list-tile-content class=\"body-2 align-end\">{{ this.singlesCount }}</v-list-tile-content>\n      </v-list-tile>\n      <v-list-tile>\n        <v-list-tile-content class=\"body-2\"><span><v-icon small color=\"rgba(225, 0, 0, 255)\">fiber_manual_record</v-icon>{{ $t('Calculated from Clusters') }}</span></v-list-tile-content>\n        <v-list-tile-content class=\"body-2 align-end\">{{ this.singlesCalculated }}</v-list-tile-content>\n      </v-list-tile>\n\n    <v-divider></v-divider>\n\n    <v-list-tile>\n      <v-list-tile-content class=\"body-2\">{{ $t('Total Egg Estimation') }}</v-list-tile-content>\n      <v-list-tile-content class=\"body-2 align-end\">{{ this.totalEggs }}</v-list-tile-content>\n    </v-list-tile>\n\n  </v-list>\n</v-card>\n</v-flex>\n\n<!-- Details pop-up window -->\n<v-dialog v-model=\"detailsDialog\" max-width=\"500px\">\n\n  <v-card>\n\n    <v-card-title>\n      <h2 class=\"title ml-2\">{{ $t('Details') }}</h2>\n    </v-card-title>\n\n    <v-card-text>\n      <v-list>\n        <v-list-tile>\n          <v-list-tile-content class=\"body-1\">{{ $t('Total Single Egg Area') }}</v-list-tile-content>\n          <v-list-tile-content class=\"align-end body-1\">{{ this.singlesTotalArea }}</v-list-tile-content>\n        </v-list-tile>\n        <v-list-tile>\n          <v-list-tile-content class=\"body-1\">{{ $t('Single Egg Average Size') }}</v-list-tile-content>\n          <v-list-tile-content class=\"align-end body-1\">{{ this.singlesAvg }}</v-list-tile-content>\n        </v-list-tile>\n        <v-list-tile>\n          <v-list-tile-content class=\"body-1\">{{ $t('Egg Clusters') }}</v-list-tile-content>\n          <v-list-tile-content class=\"align-end body-1\">{{ this.clustersCount }}</v-list-tile-content>\n        </v-list-tile>\n        <v-list-tile>\n          <v-list-tile-content class=\"body-1\">{{ $t('Total Egg Clusters Area') }}</v-list-tile-content>\n          <v-list-tile-content class=\"align-end body-1\">{{ this.clustersTotalArea }}</v-list-tile-content>\n        </v-list-tile>\n        <v-list-tile>\n          <v-list-tile-content class=\"body-1\">{{ $t('Average Cluster Area') }}</v-list-tile-content>\n          <v-list-tile-content class=\"align-end body-1\">{{ this.avgClusterArea }}</v-list-tile-content>\n        </v-list-tile>\n        <v-list-tile>\n          <v-list-tile-content class=\"body-1\">{{ $t('Average Eggs per Cluster') }}</v-list-tile-content>\n          <v-list-tile-content class=\"align-end body-1\">{{ this.avgEggsPerCluster }}</v-list-tile-content>\n        </v-list-tile>\n        <v-list-tile>\n          <v-list-tile-content class=\"body-1\">{{ $t('Image Size') }}</v-list-tile-content>\n          <v-list-tile-content class=\"align-end body-1\">{{ this.imageSize }}</v-list-tile-content>\n        </v-list-tile>\n      </v-list>\n\n    </v-card-text>\n\n    <v-card-actions>\n      <v-spacer></v-spacer>\n      <v-btn color=\"primary\" flat @click=\"detailsDialog=false\">{{ $t('Close') }}</v-btn>\n    </v-card-actions>\n\n  </v-card>\n\n</v-dialog>\n</v-layout>\n\n<v-bottom-nav app fixed :value=\"this.showBottom\" height=\"70\">\n\n  <v-btn flat color=\"primary\" @click=\"rerender()\">\n    <span>{{ $t('Reset') }}</span>\n    <v-icon>refresh</v-icon>\n  </v-btn>\n\n  <v-btn flat color=\"primary\" @click=\"showAnalysis = !showAnalysis\">\n    <span>{{ $t('Compare') }}</span>\n    <v-icon>compare</v-icon>\n  </v-btn>\n\n  <v-btn flat color=\"primary\" @click.stop=\"drawer = !drawer\">\n    <span>{{ $t('Show Filters') }}</span>\n    <v-icon>tune</v-icon>\n    </v-btn>\n\n</v-bottom-nav>\n\n</v-container>\n</div>\n</template>\n\n<script>\nimport { eventBus } from '../main.js'\n\nexport default {\n  data () {\n    return {\n      drawer: false,\n      infoExpanded: false,\n      eggsize: null,\n      analyzedImage: null,\n      imageSize: '',\n      imageDepth: '',\n      imageChannels: '',\n      imageType: '',\n      showAnalysis: true,\n      showBottom: false,\n      firstRun: true,\n      active: null,\n      analyzedImages: [{\n        output: 'src', source: 'src2' }, {\n        output: 'threshold', source: 'src3' }, {\n        output: 'objects', source: 'src5' }, {\n        output: 'outlines', source: 'src6' }, {\n        output: 'overlay', source: 'src7'\n      }],\n      analyzedImagesPretty: [\n        this.$i18n.t('Source Image'),\n        this.$i18n.t('Threshold'),\n        this.$i18n.t('Detected Objects'),\n        this.$i18n.t('Sorted Markers'),\n        this.$i18n.t('Outlined Overlay')\n      ],\n      analysisStarted: false,\n      analysisComplete: false,\n      threshValue: 120,\n      minEggRadius: 5,\n      maxEggRadius: 13,\n      maxEggCluster: 30,\n      singlesCount: 0,\n      clustersCount: 0,\n      singlesArray: [],\n      singlesTotalArea: 0,\n      clustersTotalArea: 0,\n      avgClusterArea: 0,\n      avgEggsPerCluster: 0,\n      singlesAvg: 0,\n      clustersArray: [],\n      singlesCalculated: 0,\n      eggBoxes: 0,\n      detectedObjectsArray: [],\n      detectedObjectsArrayList: [],\n      totalEggs: 0,\n      window: 0,\n      length: 5,\n      detailsDialog: false\n    }\n  },\n  created () {\n    eventBus.$on('imageType', (imageType) => {\n      if (imageType === 0) {\n        this.threshValue = 116\n        this.minEggRadius = 1\n        this.maxEggRadius = 8\n        this.maxEggCluster = 8\n      } else if (imageType === 1) {\n        this.threshValue = 120\n        this.minEggRadius = 5\n        this.maxEggRadius = 13\n        this.maxEggCluster = 30\n      } else {\n        this.threshValue = 120\n        this.minEggRadius = 4\n        this.maxEggRadius = 14\n        this.maxEggCluster = 20\n      }\n    })\n    eventBus.$on('rawImageReady', (data) => {\n      this.analyzedImage = data\n      this.load()\n    })\n  },\n  methods: {\n    async load () {\n      eventBus.$emit('loadingDialog')\n      await new Promise((resolve, reject) => setTimeout(resolve, 2000))\n      this.analyze()\n      this.turnImages()\n    },\n    rerender () {\n      eventBus.$emit('forceRerender')\n    },\n    imageMenu (index) {\n      this.active = index\n    },\n    next () {\n      this.window = this.window + 1 === this.length\n        ? 0\n        : this.window + 1\n    },\n    previous () {\n      this.window = this.window - 1 < 0\n        ? this.length - 1\n        : this.window - 1\n    },\n    async analyze () {\n      // Show 'analysis' components in Vue\n      this.analysisStarted = true\n\n      // INITIALIZATION\n      // Load image into OpenCV\n      let src = cv.imread('analyzedImage')\n      let overlay = src.clone()\n\n      // Show source image via OpenCV\n      cv.imshow('src', src)\n\n      // Image Info for debugging\n      this.imageSize = src.size().width + ' x ' + src.size().height\n      this.imageDepth = src.depth()\n      this.imageChannels = src.channels()\n      this.imageType = src.type()\n\n      // Create matrices for various analysis activites\n      let gray = new cv.Mat()\n      let threshold = new cv.Mat()\n      let dilate = new cv.Mat()\n      let boundingBoxes = new cv.Mat()\n      let objects = cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC3)\n      let outlines = new cv.Mat(src.rows, src.cols, cv.CV_8UC3, new cv.Scalar(255, 255, 255, 0))\n\n      // TRANSFORMATIONS\n      // Source to Grayscale\n      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY)\n\n      // Grayscale to Threshold (binary, not adaptive)\n      cv.threshold(gray, threshold, this.threshValue, 255, cv.THRESH_BINARY)\n\n      // Threshold to Dilate [and erode](create new matrix that can be written upon and anchor point (center))\n      let M = cv.Mat.ones(3, 3, cv.CV_8U)\n      let anchor = new cv.Point(-1, -1)\n      cv.dilate(threshold, dilate, M, anchor, 0, cv.BORDER_CONSTANT, cv.morphologyDefaultBorderValue())\n\n      // DRAW CONTOURS\n      // Create matrices to hold contour counts\n      let contours = new cv.MatVector()\n      let hierarchy = new cv.Mat()\n      let contoursObject = []\n      let contoursValues = []\n\n      // Find contours\n      cv.findContours(dilate, contours, hierarchy, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)\n\n      // CALCULATE SINGLE EGGS AND CLUSTERS\n      // Initialize and/or reset single and cluster arrays, counts, and area placeholders for computation\n      let detectedObjectsArray = []\n      this.singlesArray = []\n      this.clustersArray = []\n      this.singlesCount = 0\n      this.clustersCount = 0\n      this.singlesTotalArea = 0\n      this.clustersTotalArea = 0\n\n      // Define colors for contour object detection (boxes) and contour overlay (green=small, blue=single-egg, red=cluster)\n      let contoursColor = new cv.Scalar(255, 255, 255)\n      let green = new cv.Scalar(0, 225, 0, 255)\n      let blue = new cv.Scalar(0, 0, 225, 255)\n      let red = new cv.Scalar(255, 0, 0, 255)\n      let grayColor = new cv.Scalar(100, 100, 100, 255)\n      let minEggArea = Math.PI * (this.minEggRadius * this.minEggRadius)\n      let maxEggArea = Math.PI * (this.maxEggRadius * this.maxEggRadius)\n      let maxClusterArea = Math.PI * (this.maxEggCluster * this.maxEggCluster)\n\n      // Main loop\n      for (let i = 1; i < contours.size(); ++i) {\n        contoursObject.push(cv.contourArea(contours.get(i)))\n        contoursValues = Object.values(contoursObject)\n        let contourMax = Math.max(...contoursValues)\n        if (contourMax === cv.contourArea(contours.get(i))) {\n        } else {\n          // Draw contours and bounding boxes for all objects detected from 'contours' matrix\n          let cnt = contours.get(i)\n          let rect = cv.boundingRect(cnt)\n          cv.drawContours(objects, contours, i, contoursColor, 1, 8, hierarchy, 100)\n          let point1 = new cv.Point((rect.x - 5), (rect.y - 5))\n          let point2 = new cv.Point(rect.x + rect.width + 5, rect.y + rect.height + 5)\n          if (hierarchy.intPtr(0, i)[0] === -1 || hierarchy.intPtr(0, i)[1] === -1 || hierarchy.intPtr(0, i)[2] === -1 || hierarchy.intPtr(0, i)[3] === -1) {\n            cv.rectangle(objects, point1, point2, green, 1, cv.LINE_AA, 0)\n          } else {\n            cv.rectangle(objects, point1, point2, green, 3, cv.LINE_AA, 0)\n          }\n          // Create matrix for points of objects for all objects, even if not calculated immediately (until individual boxes invoked)\n          boundingBoxes = src.roi(rect)\n          detectedObjectsArray.push(boundingBoxes)\n          // Loop through all contours and sort/color by size, drawing on both outlines and overlay images (as well as counting towards array counts)\n          if (cv.contourArea(contours.get(i)) <= minEggArea) {\n            cv.drawContours(outlines, contours, i, grayColor, -1, cv.LINE_8, hierarchy, 0)\n            cv.drawContours(overlay, contours, i, grayColor, 1, cv.LINE_8, hierarchy, 0)\n          } else if (cv.contourArea(contours.get(i)) > minEggArea && cv.contourArea(contours.get(i)) <= maxEggArea) {\n            cv.drawContours(outlines, contours, i, blue, -1, cv.LINE_8, hierarchy, 0)\n            cv.drawContours(overlay, contours, i, blue, 1, cv.LINE_8, hierarchy, 0)\n            this.singlesArray.push(cv.contourArea(contours.get(i)))\n            ++this.singlesCount\n          } else if (cv.contourArea(contours.get(i)) > maxEggArea && cv.contourArea(contours.get(i)) <= maxClusterArea) {\n            cv.drawContours(outlines, contours, i, red, -1, cv.LINE_8, hierarchy, 0)\n            cv.drawContours(overlay, contours, i, red, 1, cv.LINE_8, hierarchy, 0)\n            this.clustersArray.push(cv.contourArea(contours.get(i)))\n            ++this.clustersCount\n          } else if (cv.contourArea(contours.get(i)) > maxClusterArea) {\n            cv.drawContours(outlines, contours, i, grayColor, -1, cv.LINE_8, hierarchy, 0)\n            cv.drawContours(overlay, contours, i, grayColor, 1, cv.LINE_8, hierarchy, 0)\n          }\n        }\n      }\n\n      // CALCULATIONS\n      // Use array counts to calculate single size averages, single size area, cluster average, and cluster area\n      for (let i = 0; i < this.singlesArray.length; i++) { this.singlesTotalArea += this.singlesArray[i] }\n      this.singlesAvg = (this.singlesTotalArea / this.singlesArray.length).toFixed(2)\n      if (isNaN(this.singlesAvg)) this.singlesAvg = 0\n\n      // Calculate cluster area if not zero, append to total cluster area of image\n      if (this.clustersCount === 0) {} else {\n        for (let i = 0; i < this.clustersArray.length; i++) {\n          this.clustersTotalArea += this.clustersArray[i]\n        }\n      }\n\n      // Calculate and convert to output formats\n      this.singlesCalculated = (this.clustersTotalArea / this.singlesAvg).toFixed(0)\n      if (isNaN(this.singlesCalculated)) this.singlesCalculated = 0\n      this.avgClusterArea = (this.clustersTotalArea / this.clustersCount).toFixed(2)\n      if (isNaN(this.avgClusterArea)) this.avgClusterArea = 0\n      this.avgEggsPerCluster = (this.avgClusterArea / this.singlesAvg).toFixed(1)\n      if (isNaN(this.avgEggsPerCluster)) this.avgEggsPerCluster = 0\n      this.totalEggs = +this.singlesCount + +this.singlesCalculated\n      this.eggEstimate = contours.size() // Egg estimation from contours\n\n      // Show images\n      cv.imshow('src', src)\n      cv.imshow('src2', src)\n      cv.imshow('src3', src)\n      cv.imshow('src5', src)\n      cv.imshow('src6', src)\n      cv.imshow('src7', src)\n      cv.imshow('threshold', threshold)\n      cv.imshow('objects', objects)\n      cv.imshow('outlines', outlines)\n      cv.imshow('overlay', overlay)\n\n      // Show legend image\n      let legend = cv.imread('legendImage')\n      cv.circle(legend, new cv.Point(50, 50), this.minEggRadius, blue, 1) // Blue inner circle\n      cv.circle(legend, new cv.Point(50, 50), this.maxEggRadius, red, 1) // Red outer circle\n      cv.circle(legend, new cv.Point(50, 50), this.maxEggCluster, grayColor, 1) // Gray outer circle\n      cv.imshow('legendCanvas', legend)\n      legend.delete()\n\n      // Delete matrices to save on memory\n      src.delete()\n      gray.delete()\n      threshold.delete()\n      dilate.delete()\n      objects.delete()\n      outlines.delete()\n      overlay.delete()\n      M.delete()\n      contours.delete()\n      hierarchy.delete()\n    },\n    async turnImages () {\n      // Use time delays to display calculation images and rotate when done calculating\n      for (let i = 4; this.window < i; ++this.window) {\n        await new Promise((resolve, reject) => setTimeout(resolve, 500))\n      }\n\n      // After timeout, show analysis results\n      await new Promise((resolve, reject) => setTimeout(resolve, 500))\n      this.analysisComplete = true\n\n      // After timeout, show bottom menu\n      await new Promise((resolve, reject) => setTimeout(resolve, 500))\n      this.showBottom = true\n    }\n  }\n}\n</script>\n\n<style scope>\n\n.imageCanvasOuter {\n  width: 100%;\n  height: 100%;\n  /* border: 3px dashed grey; */\n  display: flex;\n}\n\n.imageCanvasOuterBoxes {\n  max-height: 200px;\n  width: 100%;\n  display: flex;\n}\n\n.imageCanvasInner {\n  height: 100%;\n}\n\n.legendCanvas {\n  width: 200px;\n  height: 200px;\n}\n\n.v-text-field {\n  font-size: .9em;\n}\n\n.v-input .filter {\n  text-align: right;\n}\n\n</style>\n"],"sourceRoot":"src/components"}]}