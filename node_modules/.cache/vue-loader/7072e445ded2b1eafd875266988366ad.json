{"remainingRequest":"C:\\Users\\Patricia\\Desktop\\Raciel2\\mecvision-master\\mecvision-master\\node_modules\\@vue\\cli-service\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!C:\\Users\\Patricia\\Desktop\\Raciel2\\mecvision-master\\mecvision-master\\src\\components\\Analysis.vue?vue&type=script&lang=js&","dependencies":[{"path":"C:\\Users\\Patricia\\Desktop\\Raciel2\\mecvision-master\\mecvision-master\\src\\components\\Analysis.vue","mtime":1704750831846},{"path":"C:\\Users\\Patricia\\Desktop\\Raciel2\\mecvision-master\\mecvision-master\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\Patricia\\Desktop\\Raciel2\\mecvision-master\\mecvision-master\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"C:\\Users\\Patricia\\Desktop\\Raciel2\\mecvision-master\\mecvision-master\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"C:\\Users\\Patricia\\Desktop\\Raciel2\\mecvision-master\\mecvision-master\\node_modules\\@vue\\cli-service\\node_modules\\vue-loader\\lib\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nimport { eventBus } from '../main.js'\n\nexport default {\n  data () {\n    return {\n      drawer: false,\n      infoExpanded: false,\n      eggsize: null,\n      analyzedImage: null,\n      imageSize: '',\n      imageDepth: '',\n      imageChannels: '',\n      imageType: '',\n      showAnalysis: true,\n      showBottom: false,\n      firstRun: true,\n      active: null,\n      analyzedImages: [{\n        output: 'src', source: 'src2' }, {\n        output: 'threshold', source: 'src3' }, {\n        output: 'objects', source: 'src5' }, {\n        output: 'outlines', source: 'src6' }, {\n        output: 'overlay', source: 'src7'\n      }],\n      analyzedImagesPretty: [\n        this.$i18n.t('Source Image'),\n        this.$i18n.t('Threshold'),\n        this.$i18n.t('Detected Objects'),\n        this.$i18n.t('Sorted Markers'),\n        this.$i18n.t('Outlined Overlay')\n      ],\n      analysisStarted: false,\n      analysisComplete: false,\n      threshValue: 120,\n      minEggRadius: 5,\n      maxEggRadius: 13,\n      maxEggCluster: 30,\n      singlesCount: 0,\n      clustersCount: 0,\n      singlesArray: [],\n      singlesTotalArea: 0,\n      clustersTotalArea: 0,\n      avgClusterArea: 0,\n      avgEggsPerCluster: 0,\n      singlesAvg: 0,\n      clustersArray: [],\n      singlesCalculated: 0,\n      eggBoxes: 0,\n      detectedObjectsArray: [],\n      detectedObjectsArrayList: [],\n      totalEggs: 0,\n      window: 0,\n      length: 5,\n      detailsDialog: false\n    }\n  },\n  created () {\n    eventBus.$on('imageType', (imageType) => {\n      if (imageType === 0) {\n        this.threshValue = 116\n        this.minEggRadius = 1\n        this.maxEggRadius = 8\n        this.maxEggCluster = 8\n      } else if (imageType === 1) {\n        this.threshValue = 120\n        this.minEggRadius = 5\n        this.maxEggRadius = 13\n        this.maxEggCluster = 30\n      } else {\n        this.threshValue = 120\n        this.minEggRadius = 4\n        this.maxEggRadius = 14\n        this.maxEggCluster = 20\n      }\n    })\n    eventBus.$on('rawImageReady', (data) => {\n      this.analyzedImage = data\n      this.load()\n    })\n  },\n  methods: {\n    async load () {\n      eventBus.$emit('loadingDialog')\n      await new Promise((resolve, reject) => setTimeout(resolve, 2000))\n      this.analyze()\n      this.turnImages()\n    },\n    rerender () {\n      eventBus.$emit('forceRerender')\n    },\n    imageMenu (index) {\n      this.active = index\n    },\n    next () {\n      this.window = this.window + 1 === this.length\n        ? 0\n        : this.window + 1\n    },\n    previous () {\n      this.window = this.window - 1 < 0\n        ? this.length - 1\n        : this.window - 1\n    },\n    async analyze () {\n      // Show 'analysis' components in Vue\n      this.analysisStarted = true\n\n      // INITIALIZATION\n      // Load image into OpenCV\n      let src = cv.imread('analyzedImage')\n      let overlay = src.clone()\n\n      // Show source image via OpenCV\n      cv.imshow('src', src)\n\n      // Image Info for debugging\n      this.imageSize = src.size().width + ' x ' + src.size().height\n      this.imageDepth = src.depth()\n      this.imageChannels = src.channels()\n      this.imageType = src.type()\n\n      // Create matrices for various analysis activites\n      let gray = new cv.Mat()\n      let threshold = new cv.Mat()\n      let dilate = new cv.Mat()\n      let boundingBoxes = new cv.Mat()\n      let objects = cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC3)\n      let outlines = new cv.Mat(src.rows, src.cols, cv.CV_8UC3, new cv.Scalar(255, 255, 255, 0))\n\n      // TRANSFORMATIONS\n      // Source to Grayscale\n      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY)\n\n      // Grayscale to Threshold (binary, not adaptive)\n      cv.threshold(gray, threshold, this.threshValue, 255, cv.THRESH_BINARY)\n\n      // Threshold to Dilate [and erode](create new matrix that can be written upon and anchor point (center))\n      let M = cv.Mat.ones(3, 3, cv.CV_8U)\n      let anchor = new cv.Point(-1, -1)\n      cv.dilate(threshold, dilate, M, anchor, 0, cv.BORDER_CONSTANT, cv.morphologyDefaultBorderValue())\n\n      // DRAW CONTOURS\n      // Create matrices to hold contour counts\n      let contours = new cv.MatVector()\n      let hierarchy = new cv.Mat()\n      let contoursObject = []\n      let contoursValues = []\n\n      // Find contours\n      cv.findContours(dilate, contours, hierarchy, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)\n\n      // CALCULATE SINGLE EGGS AND CLUSTERS\n      // Initialize and/or reset single and cluster arrays, counts, and area placeholders for computation\n      let detectedObjectsArray = []\n      this.singlesArray = []\n      this.clustersArray = []\n      this.singlesCount = 0\n      this.clustersCount = 0\n      this.singlesTotalArea = 0\n      this.clustersTotalArea = 0\n\n      // Define colors for contour object detection (boxes) and contour overlay (green=small, blue=single-egg, red=cluster)\n      let contoursColor = new cv.Scalar(255, 255, 255)\n      let green = new cv.Scalar(0, 225, 0, 255)\n      let blue = new cv.Scalar(0, 0, 225, 255)\n      let red = new cv.Scalar(255, 0, 0, 255)\n      let grayColor = new cv.Scalar(100, 100, 100, 255)\n      let minEggArea = Math.PI * (this.minEggRadius * this.minEggRadius)\n      let maxEggArea = Math.PI * (this.maxEggRadius * this.maxEggRadius)\n      let maxClusterArea = Math.PI * (this.maxEggCluster * this.maxEggCluster)\n\n      // Main loop\n      for (let i = 1; i < contours.size(); ++i) {\n        contoursObject.push(cv.contourArea(contours.get(i)))\n        contoursValues = Object.values(contoursObject)\n        let contourMax = Math.max(...contoursValues)\n        if (contourMax === cv.contourArea(contours.get(i))) {\n        } else {\n          // Draw contours and bounding boxes for all objects detected from 'contours' matrix\n          let cnt = contours.get(i)\n          let rect = cv.boundingRect(cnt)\n          cv.drawContours(objects, contours, i, contoursColor, 1, 8, hierarchy, 100)\n          let point1 = new cv.Point((rect.x - 5), (rect.y - 5))\n          let point2 = new cv.Point(rect.x + rect.width + 5, rect.y + rect.height + 5)\n          if (hierarchy.intPtr(0, i)[0] === -1 || hierarchy.intPtr(0, i)[1] === -1 || hierarchy.intPtr(0, i)[2] === -1 || hierarchy.intPtr(0, i)[3] === -1) {\n            cv.rectangle(objects, point1, point2, green, 1, cv.LINE_AA, 0)\n          } else {\n            cv.rectangle(objects, point1, point2, green, 3, cv.LINE_AA, 0)\n          }\n          // Create matrix for points of objects for all objects, even if not calculated immediately (until individual boxes invoked)\n          boundingBoxes = src.roi(rect)\n          detectedObjectsArray.push(boundingBoxes)\n          // Loop through all contours and sort/color by size, drawing on both outlines and overlay images (as well as counting towards array counts)\n          if (cv.contourArea(contours.get(i)) <= minEggArea) {\n            cv.drawContours(outlines, contours, i, grayColor, -1, cv.LINE_8, hierarchy, 0)\n            cv.drawContours(overlay, contours, i, grayColor, 1, cv.LINE_8, hierarchy, 0)\n          } else if (cv.contourArea(contours.get(i)) > minEggArea && cv.contourArea(contours.get(i)) <= maxEggArea) {\n            cv.drawContours(outlines, contours, i, blue, -1, cv.LINE_8, hierarchy, 0)\n            cv.drawContours(overlay, contours, i, blue, 1, cv.LINE_8, hierarchy, 0)\n            this.singlesArray.push(cv.contourArea(contours.get(i)))\n            ++this.singlesCount\n          } else if (cv.contourArea(contours.get(i)) > maxEggArea && cv.contourArea(contours.get(i)) <= maxClusterArea) {\n            cv.drawContours(outlines, contours, i, red, -1, cv.LINE_8, hierarchy, 0)\n            cv.drawContours(overlay, contours, i, red, 1, cv.LINE_8, hierarchy, 0)\n            this.clustersArray.push(cv.contourArea(contours.get(i)))\n            ++this.clustersCount\n          } else if (cv.contourArea(contours.get(i)) > maxClusterArea) {\n            cv.drawContours(outlines, contours, i, grayColor, -1, cv.LINE_8, hierarchy, 0)\n            cv.drawContours(overlay, contours, i, grayColor, 1, cv.LINE_8, hierarchy, 0)\n          }\n        }\n      }\n\n      // CALCULATIONS\n      // Use array counts to calculate single size averages, single size area, cluster average, and cluster area\n      for (let i = 0; i < this.singlesArray.length; i++) { this.singlesTotalArea += this.singlesArray[i] }\n      this.singlesAvg = (this.singlesTotalArea / this.singlesArray.length).toFixed(2)\n      if (isNaN(this.singlesAvg)) this.singlesAvg = 0\n\n      // Calculate cluster area if not zero, append to total cluster area of image\n      if (this.clustersCount === 0) {} else {\n        for (let i = 0; i < this.clustersArray.length; i++) {\n          this.clustersTotalArea += this.clustersArray[i]\n        }\n      }\n\n      // Calculate and convert to output formats\n      this.singlesCalculated = (this.clustersTotalArea / this.singlesAvg).toFixed(0)\n      if (isNaN(this.singlesCalculated)) this.singlesCalculated = 0\n      this.avgClusterArea = (this.clustersTotalArea / this.clustersCount).toFixed(2)\n      if (isNaN(this.avgClusterArea)) this.avgClusterArea = 0\n      this.avgEggsPerCluster = (this.avgClusterArea / this.singlesAvg).toFixed(1)\n      if (isNaN(this.avgEggsPerCluster)) this.avgEggsPerCluster = 0\n      this.totalEggs = +this.singlesCount + +this.singlesCalculated\n      this.eggEstimate = contours.size() // Egg estimation from contours\n\n      // Show images\n      cv.imshow('src', src)\n      cv.imshow('src2', src)\n      cv.imshow('src3', src)\n      cv.imshow('src5', src)\n      cv.imshow('src6', src)\n      cv.imshow('src7', src)\n      cv.imshow('threshold', threshold)\n      cv.imshow('objects', objects)\n      cv.imshow('outlines', outlines)\n      cv.imshow('overlay', overlay)\n\n      // Show legend image\n      let legend = cv.imread('legendImage')\n      cv.circle(legend, new cv.Point(50, 50), this.minEggRadius, blue, 1) // Blue inner circle\n      cv.circle(legend, new cv.Point(50, 50), this.maxEggRadius, red, 1) // Red outer circle\n      cv.circle(legend, new cv.Point(50, 50), this.maxEggCluster, grayColor, 1) // Gray outer circle\n      cv.imshow('legendCanvas', legend)\n      legend.delete()\n\n      // Delete matrices to save on memory\n      src.delete()\n      gray.delete()\n      threshold.delete()\n      dilate.delete()\n      objects.delete()\n      outlines.delete()\n      overlay.delete()\n      M.delete()\n      contours.delete()\n      hierarchy.delete()\n    },\n    async turnImages () {\n      // Use time delays to display calculation images and rotate when done calculating\n      for (let i = 4; this.window < i; ++this.window) {\n        await new Promise((resolve, reject) => setTimeout(resolve, 500))\n      }\n\n      // After timeout, show analysis results\n      await new Promise((resolve, reject) => setTimeout(resolve, 500))\n      this.analysisComplete = true\n\n      // After timeout, show bottom menu\n      await new Promise((resolve, reject) => setTimeout(resolve, 500))\n      this.showBottom = true\n    }\n  }\n}\n",{"version":3,"sources":["Analysis.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwQA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA","file":"Analysis.vue","sourceRoot":"src/components","sourcesContent":["<template>\n<div>\n\n  <v-container fluid>\n    <v-layout row wrap>\n      <v-flex xs12 md8 lg8 xl9 v-show=\"analysisStarted\">\n\n<!-- Analysis window -- increments between analyses, using Vuetify window components -->\n<v-window v-model=\"window\" class=\"elevation-5\">\n  <v-window-item v-for=\"item in analyzedImages\" :key=\"item.output\" :transition=\"false\" :reverse-transition=\"false\">\n\n    <!-- OpenCV injects to canvas items -->\n    <canvas :id=\"item.output\" class=\"imageCanvasOuter\" v-show=\"showAnalysis\">\n      <img class=\"imageCanvasInner\" id=\"analyzedImage\" :src=\"analyzedImage\" style=\"height:100px;\"/>\n    </canvas>\n\n    <!-- Keep a copy of the original source hidden under the analysis, for comparison toggle to work -->\n    <canvas :id=\"item.source\" class=\"imageCanvasOuter\" v-show=\"!showAnalysis\">\n      <img class=\"imageCanvasInner\" id=\"analyzedImage\" :src=\"analyzedImage\" />\n    </canvas>\n\n  </v-window-item>\n  </v-window>\n\n  <!-- Options for the analysis windows -->\n  <v-card class=\"my-3\">\n    <v-card-title>\n      <v-layout align-center wrap>\n        <v-flex>\n          <h1 :class=\"{'title': $vuetify.breakpoint.smAndDown, 'display-1': $vuetify.breakpoint.mdAndUp}\">{{ analyzedImagesPretty[this.window] }}</h1>\n          <h2 :class=\"{'subheading': $vuetify.breakpoint.smAndDown, 'title mt-2': $vuetify.breakpoint.mdAndUp}\">({{this.window+1}} {{ $t('of') }} {{this.length}})</h2>\n        </v-flex>\n        <v-spacer></v-spacer>\n        <v-layout justify-end row :class=\"{'': $vuetify.breakpoint.smAndDown, 'shrink': $vuetify.breakpoint.mdAndUp}\">\n        <v-flex shrink class=\"text-xs-center\">\n          <v-btn icon color=\"primary\" @click=\"previous\"><v-icon>chevron_left</v-icon>\n          </v-btn>\n        </v-flex>\n        <v-flex shrink class=\"text-xs-center\">\n          <v-btn icon color=\"primary\" @click=\"next\"><v-icon>chevron_right</v-icon>\n          </v-btn>\n        </v-flex>\n        </v-layout>\n      </v-layout>\n    </v-card-title>\n  </v-card>\n\n  </v-flex>\n\n  <v-flex xs12 md4 lg3 xl3 :class=\"{'pl-0': $vuetify.breakpoint.smAndDown, 'pl-3': $vuetify.breakpoint.mdAndUp}\" v-show=\"analysisComplete\">\n\n  <!-- Filters for fine-tuning image and analysis -->\n  <div v-show=\"drawer\">\n    <v-card class=\"mb-2\">\n      <v-card-title>\n        <h4 class=\"title\">{{ $t('Filters') }}</h4>\n      </v-card-title>\n      <v-card-text class=\"pt-0\">\n\n      <v-layout>\n        <v-tooltip bottom>\n        <template v-slot:activator=\"{ on }\">\n        <v-flex class=\"subheading\"><span v-on=\"on\">{{ $t('Image Threshold Adjustment') }}</span></v-flex>\n        </template>\n        <span>{{ $t('Image Threshold Adjustment Details') }}</span>\n        </v-tooltip>\n      </v-layout>\n\n      <v-layout row>\n        <v-flex>\n          <v-slider v-model=\"threshValue\" :max=\"255\" @change=\"analyze()\"></v-slider>\n        </v-flex>\n        <v-flex xs3 md2 xl2 mx-2>\n        <v-text-field solo v-model=\"threshValue\" hide-details single-line class=\"filter\"></v-text-field>\n        </v-flex>\n      </v-layout>\n\n      <v-layout>\n        <v-tooltip bottom>\n        <template v-slot:activator=\"{ on }\">\n        <v-flex class=\"subheading\"><span v-on=\"on\">{{ $t('Minimum Egg Size') }}</span></v-flex>\n        </template>\n        <span>{{ $t(\"Minimum Egg Size Details\") }}</span>\n        </v-tooltip>\n      </v-layout>\n\n      <v-layout row>\n        <v-flex mx-3>\n          <v-slider v-model=\"minEggRadius\" :min=\"0\" :max=\"100\" @change=\"analyze()\"></v-slider>\n        </v-flex>\n        <v-flex xs8 md5 lg4 xl3>\n        <v-text-field solo v-model=\"minEggRadius\" hide-details single-line></v-text-field>\n        </v-flex>\n      </v-layout>\n\n      <v-layout>\n        <v-tooltip bottom>\n        <template v-slot:activator=\"{ on }\">\n        <v-flex class=\"subheading\"><span v-on=\"on\">{{ $t('Maximum Egg Size') }}</span></v-flex>\n        </template>\n        <span>{{ $t('Maximum Egg Size Details') }}</span>\n        </v-tooltip>\n      </v-layout>\n\n      <v-layout row>\n        <v-flex mx-3>\n          <v-slider v-model=\"maxEggRadius\" :min=\"0\" :max=\"100\" @change=\"analyze()\"></v-slider>\n        </v-flex>\n        <v-flex xs8 md5 lg4 xl3>\n        <v-text-field solo v-model=\"maxEggRadius\" hide-details single-line></v-text-field>\n        </v-flex>\n      </v-layout>\n\n      <v-layout>\n        <v-tooltip bottom>\n        <template v-slot:activator=\"{ on }\">\n        <v-flex class=\"subheading\"><span v-on=\"on\">{{ $t('Maximum Cluster Size') }}</span></v-flex>\n        </template>\n        <span>{{ $t('Maximum Cluster Size Details') }}</span>\n        </v-tooltip>\n      </v-layout>\n\n      <v-layout row>\n        <v-flex mx-3>\n          <v-slider v-model=\"maxEggCluster\" :min=\"0\" :max=\"100\" @change=\"analyze()\"></v-slider>\n        </v-flex>\n        <v-flex xs8 md5 lg4 xl3>\n        <v-text-field solo v-model=\"maxEggCluster\" hide-details single-line></v-text-field>\n        </v-flex>\n      </v-layout>\n\n      <v-layout row wrap align-center>\n        <v-tooltip bottom>\n        <template v-slot:activator=\"{ on }\">\n        <v-flex class=\"subheading mb-1\">\n          <span v-on=\"on\">\n          <p class=\"mb-1\">{{ $t('Egg Size Scale') }}</p>\n          <p class=\"caption my-0\"><v-icon small color=\"rgba(0, 0, 225, 255)\">fiber_manual_record</v-icon> {{ $t('Minimum Egg Size') }}</p>\n          <p class=\"caption my-0\"><v-icon small color=\"rgba(225, 0, 0, 255)\">fiber_manual_record</v-icon> {{ $t('Maximum Egg Size') }}</p>\n          <p class=\"caption my-0\"><v-icon small color=\"rgba(100, 100, 100, 255)\">fiber_manual_record</v-icon> {{ $t('Too Large / Too Small') }}</p>\n          </span>\n          </v-flex>\n        </template>\n        <span>{{ $t('Egg Size Scale Details') }}</span>\n        </v-tooltip>\n\n        <v-flex>\n          <canvas id=\"legendCanvas\" style=\"margin: auto; display: block;\"><img id=\"legendImage\" src=\"/img/legend.png\" /></canvas>\n        </v-flex>\n      </v-layout>\n\n    </v-card-text>\n  </v-card>\n\n  </div>\n\n  <!-- Analysis Card -- showing details -->\n  <v-card>\n    <v-card-title class=\"justify-end\">\n      <h4 class=\"title\">{{ $t('Analysis') }}</h4>\n      <v-spacer></v-spacer>\n      <v-btn class=\"mr-0\" color=\"primary\" dark @click=\"detailsDialog = true\">{{ $t('Details') }}</v-btn>\n    </v-card-title>\n\n    <v-divider></v-divider>\n\n    <v-list>\n      <v-list-tile>\n        <v-list-tile-content class=\"body-2\"><span><v-icon small color=\"rgba(0, 0, 225, 255)\">fiber_manual_record</v-icon>{{ $t('Single Eggs') }}</span></v-list-tile-content>\n        <v-list-tile-content class=\"body-2 align-end\">{{ this.singlesCount }}</v-list-tile-content>\n      </v-list-tile>\n      <v-list-tile>\n        <v-list-tile-content class=\"body-2\"><span><v-icon small color=\"rgba(225, 0, 0, 255)\">fiber_manual_record</v-icon>{{ $t('Calculated from Clusters') }}</span></v-list-tile-content>\n        <v-list-tile-content class=\"body-2 align-end\">{{ this.singlesCalculated }}</v-list-tile-content>\n      </v-list-tile>\n\n    <v-divider></v-divider>\n\n    <v-list-tile>\n      <v-list-tile-content class=\"body-2\">{{ $t('Total Egg Estimation') }}</v-list-tile-content>\n      <v-list-tile-content class=\"body-2 align-end\">{{ this.totalEggs }}</v-list-tile-content>\n    </v-list-tile>\n\n  </v-list>\n</v-card>\n</v-flex>\n\n<!-- Details pop-up window -->\n<v-dialog v-model=\"detailsDialog\" max-width=\"500px\">\n\n  <v-card>\n\n    <v-card-title>\n      <h2 class=\"title ml-2\">{{ $t('Details') }}</h2>\n    </v-card-title>\n\n    <v-card-text>\n      <v-list>\n        <v-list-tile>\n          <v-list-tile-content class=\"body-1\">{{ $t('Total Single Egg Area') }}</v-list-tile-content>\n          <v-list-tile-content class=\"align-end body-1\">{{ this.singlesTotalArea }}</v-list-tile-content>\n        </v-list-tile>\n        <v-list-tile>\n          <v-list-tile-content class=\"body-1\">{{ $t('Single Egg Average Size') }}</v-list-tile-content>\n          <v-list-tile-content class=\"align-end body-1\">{{ this.singlesAvg }}</v-list-tile-content>\n        </v-list-tile>\n        <v-list-tile>\n          <v-list-tile-content class=\"body-1\">{{ $t('Egg Clusters') }}</v-list-tile-content>\n          <v-list-tile-content class=\"align-end body-1\">{{ this.clustersCount }}</v-list-tile-content>\n        </v-list-tile>\n        <v-list-tile>\n          <v-list-tile-content class=\"body-1\">{{ $t('Total Egg Clusters Area') }}</v-list-tile-content>\n          <v-list-tile-content class=\"align-end body-1\">{{ this.clustersTotalArea }}</v-list-tile-content>\n        </v-list-tile>\n        <v-list-tile>\n          <v-list-tile-content class=\"body-1\">{{ $t('Average Cluster Area') }}</v-list-tile-content>\n          <v-list-tile-content class=\"align-end body-1\">{{ this.avgClusterArea }}</v-list-tile-content>\n        </v-list-tile>\n        <v-list-tile>\n          <v-list-tile-content class=\"body-1\">{{ $t('Average Eggs per Cluster') }}</v-list-tile-content>\n          <v-list-tile-content class=\"align-end body-1\">{{ this.avgEggsPerCluster }}</v-list-tile-content>\n        </v-list-tile>\n        <v-list-tile>\n          <v-list-tile-content class=\"body-1\">{{ $t('Image Size') }}</v-list-tile-content>\n          <v-list-tile-content class=\"align-end body-1\">{{ this.imageSize }}</v-list-tile-content>\n        </v-list-tile>\n      </v-list>\n\n    </v-card-text>\n\n    <v-card-actions>\n      <v-spacer></v-spacer>\n      <v-btn color=\"primary\" flat @click=\"detailsDialog=false\">{{ $t('Close') }}</v-btn>\n    </v-card-actions>\n\n  </v-card>\n\n</v-dialog>\n</v-layout>\n\n<v-bottom-nav app fixed :value=\"this.showBottom\" height=\"70\">\n\n  <v-btn flat color=\"primary\" @click=\"rerender()\">\n    <span>{{ $t('Reset') }}</span>\n    <v-icon>refresh</v-icon>\n  </v-btn>\n\n  <v-btn flat color=\"primary\" @click=\"showAnalysis = !showAnalysis\">\n    <span>{{ $t('Compare') }}</span>\n    <v-icon>compare</v-icon>\n  </v-btn>\n\n  <v-btn flat color=\"primary\" @click.stop=\"drawer = !drawer\">\n    <span>{{ $t('Show Filters') }}</span>\n    <v-icon>tune</v-icon>\n    </v-btn>\n\n</v-bottom-nav>\n\n</v-container>\n</div>\n</template>\n\n<script>\nimport { eventBus } from '../main.js'\n\nexport default {\n  data () {\n    return {\n      drawer: false,\n      infoExpanded: false,\n      eggsize: null,\n      analyzedImage: null,\n      imageSize: '',\n      imageDepth: '',\n      imageChannels: '',\n      imageType: '',\n      showAnalysis: true,\n      showBottom: false,\n      firstRun: true,\n      active: null,\n      analyzedImages: [{\n        output: 'src', source: 'src2' }, {\n        output: 'threshold', source: 'src3' }, {\n        output: 'objects', source: 'src5' }, {\n        output: 'outlines', source: 'src6' }, {\n        output: 'overlay', source: 'src7'\n      }],\n      analyzedImagesPretty: [\n        this.$i18n.t('Source Image'),\n        this.$i18n.t('Threshold'),\n        this.$i18n.t('Detected Objects'),\n        this.$i18n.t('Sorted Markers'),\n        this.$i18n.t('Outlined Overlay')\n      ],\n      analysisStarted: false,\n      analysisComplete: false,\n      threshValue: 120,\n      minEggRadius: 5,\n      maxEggRadius: 13,\n      maxEggCluster: 30,\n      singlesCount: 0,\n      clustersCount: 0,\n      singlesArray: [],\n      singlesTotalArea: 0,\n      clustersTotalArea: 0,\n      avgClusterArea: 0,\n      avgEggsPerCluster: 0,\n      singlesAvg: 0,\n      clustersArray: [],\n      singlesCalculated: 0,\n      eggBoxes: 0,\n      detectedObjectsArray: [],\n      detectedObjectsArrayList: [],\n      totalEggs: 0,\n      window: 0,\n      length: 5,\n      detailsDialog: false\n    }\n  },\n  created () {\n    eventBus.$on('imageType', (imageType) => {\n      if (imageType === 0) {\n        this.threshValue = 116\n        this.minEggRadius = 1\n        this.maxEggRadius = 8\n        this.maxEggCluster = 8\n      } else if (imageType === 1) {\n        this.threshValue = 120\n        this.minEggRadius = 5\n        this.maxEggRadius = 13\n        this.maxEggCluster = 30\n      } else {\n        this.threshValue = 120\n        this.minEggRadius = 4\n        this.maxEggRadius = 14\n        this.maxEggCluster = 20\n      }\n    })\n    eventBus.$on('rawImageReady', (data) => {\n      this.analyzedImage = data\n      this.load()\n    })\n  },\n  methods: {\n    async load () {\n      eventBus.$emit('loadingDialog')\n      await new Promise((resolve, reject) => setTimeout(resolve, 2000))\n      this.analyze()\n      this.turnImages()\n    },\n    rerender () {\n      eventBus.$emit('forceRerender')\n    },\n    imageMenu (index) {\n      this.active = index\n    },\n    next () {\n      this.window = this.window + 1 === this.length\n        ? 0\n        : this.window + 1\n    },\n    previous () {\n      this.window = this.window - 1 < 0\n        ? this.length - 1\n        : this.window - 1\n    },\n    async analyze () {\n      // Show 'analysis' components in Vue\n      this.analysisStarted = true\n\n      // INITIALIZATION\n      // Load image into OpenCV\n      let src = cv.imread('analyzedImage')\n      let overlay = src.clone()\n\n      // Show source image via OpenCV\n      cv.imshow('src', src)\n\n      // Image Info for debugging\n      this.imageSize = src.size().width + ' x ' + src.size().height\n      this.imageDepth = src.depth()\n      this.imageChannels = src.channels()\n      this.imageType = src.type()\n\n      // Create matrices for various analysis activites\n      let gray = new cv.Mat()\n      let threshold = new cv.Mat()\n      let dilate = new cv.Mat()\n      let boundingBoxes = new cv.Mat()\n      let objects = cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC3)\n      let outlines = new cv.Mat(src.rows, src.cols, cv.CV_8UC3, new cv.Scalar(255, 255, 255, 0))\n\n      // TRANSFORMATIONS\n      // Source to Grayscale\n      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY)\n\n      // Grayscale to Threshold (binary, not adaptive)\n      cv.threshold(gray, threshold, this.threshValue, 255, cv.THRESH_BINARY)\n\n      // Threshold to Dilate [and erode](create new matrix that can be written upon and anchor point (center))\n      let M = cv.Mat.ones(3, 3, cv.CV_8U)\n      let anchor = new cv.Point(-1, -1)\n      cv.dilate(threshold, dilate, M, anchor, 0, cv.BORDER_CONSTANT, cv.morphologyDefaultBorderValue())\n\n      // DRAW CONTOURS\n      // Create matrices to hold contour counts\n      let contours = new cv.MatVector()\n      let hierarchy = new cv.Mat()\n      let contoursObject = []\n      let contoursValues = []\n\n      // Find contours\n      cv.findContours(dilate, contours, hierarchy, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)\n\n      // CALCULATE SINGLE EGGS AND CLUSTERS\n      // Initialize and/or reset single and cluster arrays, counts, and area placeholders for computation\n      let detectedObjectsArray = []\n      this.singlesArray = []\n      this.clustersArray = []\n      this.singlesCount = 0\n      this.clustersCount = 0\n      this.singlesTotalArea = 0\n      this.clustersTotalArea = 0\n\n      // Define colors for contour object detection (boxes) and contour overlay (green=small, blue=single-egg, red=cluster)\n      let contoursColor = new cv.Scalar(255, 255, 255)\n      let green = new cv.Scalar(0, 225, 0, 255)\n      let blue = new cv.Scalar(0, 0, 225, 255)\n      let red = new cv.Scalar(255, 0, 0, 255)\n      let grayColor = new cv.Scalar(100, 100, 100, 255)\n      let minEggArea = Math.PI * (this.minEggRadius * this.minEggRadius)\n      let maxEggArea = Math.PI * (this.maxEggRadius * this.maxEggRadius)\n      let maxClusterArea = Math.PI * (this.maxEggCluster * this.maxEggCluster)\n\n      // Main loop\n      for (let i = 1; i < contours.size(); ++i) {\n        contoursObject.push(cv.contourArea(contours.get(i)))\n        contoursValues = Object.values(contoursObject)\n        let contourMax = Math.max(...contoursValues)\n        if (contourMax === cv.contourArea(contours.get(i))) {\n        } else {\n          // Draw contours and bounding boxes for all objects detected from 'contours' matrix\n          let cnt = contours.get(i)\n          let rect = cv.boundingRect(cnt)\n          cv.drawContours(objects, contours, i, contoursColor, 1, 8, hierarchy, 100)\n          let point1 = new cv.Point((rect.x - 5), (rect.y - 5))\n          let point2 = new cv.Point(rect.x + rect.width + 5, rect.y + rect.height + 5)\n          if (hierarchy.intPtr(0, i)[0] === -1 || hierarchy.intPtr(0, i)[1] === -1 || hierarchy.intPtr(0, i)[2] === -1 || hierarchy.intPtr(0, i)[3] === -1) {\n            cv.rectangle(objects, point1, point2, green, 1, cv.LINE_AA, 0)\n          } else {\n            cv.rectangle(objects, point1, point2, green, 3, cv.LINE_AA, 0)\n          }\n          // Create matrix for points of objects for all objects, even if not calculated immediately (until individual boxes invoked)\n          boundingBoxes = src.roi(rect)\n          detectedObjectsArray.push(boundingBoxes)\n          // Loop through all contours and sort/color by size, drawing on both outlines and overlay images (as well as counting towards array counts)\n          if (cv.contourArea(contours.get(i)) <= minEggArea) {\n            cv.drawContours(outlines, contours, i, grayColor, -1, cv.LINE_8, hierarchy, 0)\n            cv.drawContours(overlay, contours, i, grayColor, 1, cv.LINE_8, hierarchy, 0)\n          } else if (cv.contourArea(contours.get(i)) > minEggArea && cv.contourArea(contours.get(i)) <= maxEggArea) {\n            cv.drawContours(outlines, contours, i, blue, -1, cv.LINE_8, hierarchy, 0)\n            cv.drawContours(overlay, contours, i, blue, 1, cv.LINE_8, hierarchy, 0)\n            this.singlesArray.push(cv.contourArea(contours.get(i)))\n            ++this.singlesCount\n          } else if (cv.contourArea(contours.get(i)) > maxEggArea && cv.contourArea(contours.get(i)) <= maxClusterArea) {\n            cv.drawContours(outlines, contours, i, red, -1, cv.LINE_8, hierarchy, 0)\n            cv.drawContours(overlay, contours, i, red, 1, cv.LINE_8, hierarchy, 0)\n            this.clustersArray.push(cv.contourArea(contours.get(i)))\n            ++this.clustersCount\n          } else if (cv.contourArea(contours.get(i)) > maxClusterArea) {\n            cv.drawContours(outlines, contours, i, grayColor, -1, cv.LINE_8, hierarchy, 0)\n            cv.drawContours(overlay, contours, i, grayColor, 1, cv.LINE_8, hierarchy, 0)\n          }\n        }\n      }\n\n      // CALCULATIONS\n      // Use array counts to calculate single size averages, single size area, cluster average, and cluster area\n      for (let i = 0; i < this.singlesArray.length; i++) { this.singlesTotalArea += this.singlesArray[i] }\n      this.singlesAvg = (this.singlesTotalArea / this.singlesArray.length).toFixed(2)\n      if (isNaN(this.singlesAvg)) this.singlesAvg = 0\n\n      // Calculate cluster area if not zero, append to total cluster area of image\n      if (this.clustersCount === 0) {} else {\n        for (let i = 0; i < this.clustersArray.length; i++) {\n          this.clustersTotalArea += this.clustersArray[i]\n        }\n      }\n\n      // Calculate and convert to output formats\n      this.singlesCalculated = (this.clustersTotalArea / this.singlesAvg).toFixed(0)\n      if (isNaN(this.singlesCalculated)) this.singlesCalculated = 0\n      this.avgClusterArea = (this.clustersTotalArea / this.clustersCount).toFixed(2)\n      if (isNaN(this.avgClusterArea)) this.avgClusterArea = 0\n      this.avgEggsPerCluster = (this.avgClusterArea / this.singlesAvg).toFixed(1)\n      if (isNaN(this.avgEggsPerCluster)) this.avgEggsPerCluster = 0\n      this.totalEggs = +this.singlesCount + +this.singlesCalculated\n      this.eggEstimate = contours.size() // Egg estimation from contours\n\n      // Show images\n      cv.imshow('src', src)\n      cv.imshow('src2', src)\n      cv.imshow('src3', src)\n      cv.imshow('src5', src)\n      cv.imshow('src6', src)\n      cv.imshow('src7', src)\n      cv.imshow('threshold', threshold)\n      cv.imshow('objects', objects)\n      cv.imshow('outlines', outlines)\n      cv.imshow('overlay', overlay)\n\n      // Show legend image\n      let legend = cv.imread('legendImage')\n      cv.circle(legend, new cv.Point(50, 50), this.minEggRadius, blue, 1) // Blue inner circle\n      cv.circle(legend, new cv.Point(50, 50), this.maxEggRadius, red, 1) // Red outer circle\n      cv.circle(legend, new cv.Point(50, 50), this.maxEggCluster, grayColor, 1) // Gray outer circle\n      cv.imshow('legendCanvas', legend)\n      legend.delete()\n\n      // Delete matrices to save on memory\n      src.delete()\n      gray.delete()\n      threshold.delete()\n      dilate.delete()\n      objects.delete()\n      outlines.delete()\n      overlay.delete()\n      M.delete()\n      contours.delete()\n      hierarchy.delete()\n    },\n    async turnImages () {\n      // Use time delays to display calculation images and rotate when done calculating\n      for (let i = 4; this.window < i; ++this.window) {\n        await new Promise((resolve, reject) => setTimeout(resolve, 500))\n      }\n\n      // After timeout, show analysis results\n      await new Promise((resolve, reject) => setTimeout(resolve, 500))\n      this.analysisComplete = true\n\n      // After timeout, show bottom menu\n      await new Promise((resolve, reject) => setTimeout(resolve, 500))\n      this.showBottom = true\n    }\n  }\n}\n</script>\n\n<style scope>\n\n.imageCanvasOuter {\n  width: 100%;\n  height: 100%;\n  /* border: 3px dashed grey; */\n  display: flex;\n}\n\n.imageCanvasOuterBoxes {\n  max-height: 200px;\n  width: 100%;\n  display: flex;\n}\n\n.imageCanvasInner {\n  height: 100%;\n}\n\n.legendCanvas {\n  width: 200px;\n  height: 200px;\n}\n\n.v-text-field {\n  font-size: .9em;\n}\n\n.v-input .filter {\n  text-align: right;\n}\n\n</style>\n"]}]}